---
layout: post
title: 電子負荷を作る
category: 電子工作
tag:
    - 電子負荷
    - STM32
comments: true
thumb: /images/thumb_eload.jpg
---
電子負荷を作りました。20V 10Aまで使えます。 



# はじめに
電子負荷を作りました。20V 10Aまで使えて、電力を消費するMOSFETをPC用CPUクーラーで冷やしているのが特徴です。
意図せずAliexpressで「電子負荷」と検索すると出てくる電子負荷に似てしまいました。

![](/images/eload.jpg){:data-action="zoom"}

仕様・特徴は以下の通りです。
* 0~20V、10AのCC動作が可能 (定常的には50Wくらいまで)
* 液晶画面に以下の情報を表示
    * 設定電流
    * 測定電流・電圧
    * 冷却FANの回転数
    * 電力を消費するMOSFETの温度
* 過電圧、過電流、過熱保護
* MOSFETの発熱に応じてファンの回転数を制御する

電流設定値を変更している様子はこんな感じです。

<blockquote class="twitter-tweet"><p lang="ja" dir="ltr">電子負荷のUIと過電圧保護みたいなのができた <a href="https://t.co/1JHDSo7zuY">pic.twitter.com/1JHDSo7zuY</a></p>&mdash; id (@idt12312) <a href="https://twitter.com/idt12312/status/1434432940251832320?ref_src=twsrc%5Etfw">September 5, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

最近作ったスイッチング電源の動作確認をする際の負荷として活躍しました。
負荷として電力定格の大きい抵抗を使ってもテストはできますが、この電子負荷を使うとボタン操作だけで負荷電流を変更できます。
あと、これ一つで電流電圧の測定もできて便利です。

![](/images/eload_dcdc.jpg){:data-action="zoom"}


# 全体構成

この電子負荷は以下のような構成です。

![](/images/eload_block_diagram.svg){:data-action="zoom"}

全体の回路図は以下の場所から見れます。

[**電子負荷: 回路図**](/data/eload.pdf)

以降では特に以下の項目について掘り下げていきます。

* アナログ回路部分
* マイコンでの測定とフィードバック制御
* 放熱とファン制御

# アナログ回路部分

アナログ回路部分には電圧電流測定回路と電子負荷回路があります。
重要な部分だけを抜き出した回路図は以下の通りです。

![](/images/eload_analog.svg){:data-action="zoom"}

## 電圧電流測定回路

電圧電流測定回路はともにopampで作った差動増幅回路です。

電流測定回路では電流をシャント抵抗で電圧に変換し、それを差動増幅回路で増幅しています。
シャント抵抗は4端子パッケージのものを使っています。
差動増幅回路+4端子抵抗できっちり抵抗の両端の電圧を測ることで、配線での電圧降下の影響を受けないようにしています。

電圧測定回路のopampの電源電圧は12Vです。
差動増幅回路のゲインが1より小さい0.5倍なので、22Vくらいまで電圧を電圧測定ができます。
22Vくらいを入力してもopampの入力端子の電圧は12Vに収まるので、問題なく電圧が測定できます。


## 電子負荷回路

opamp、MOSFET、電流測定回路により、MOSFETで電力を消費させる電子負荷回路を実装しています。
MOSFETは消費した電力分だけ発熱をするので、放熱のために大きなヒートシンクを取り付けています。

opampは電流測定値とマイコンのDACから入力される目標電流を比較し、それらが等しくなるようにMOSFETのゲート電圧を変化させます。
この動作により出力電流がフィードバック制御されます。

電子負荷につながる回路によってはopampの出力電圧から実際に流れる電流までの伝達に大きな遅れが発生し、フィードバック系が発振します。
具体的には、電子負荷の出力につながる先のインダクタ成分が増えると増えるほど系は不安定になっていきます。
対策として、電流制御の帯域をある程度に制限することで、電流制御の応答が遅くなる代わりに発振しにくくしています。

電流制御の帯域はCf、Rfで決まっていて、電流設定値→出力電流の応答の時定数はCf*Rfになります。
今は電流制御の帯域が1.6kHzくらいで、100uHくらいまでのL負荷をつないでも発振しない設計です。

この回路はマイクロマウスのためのLEDの定電流回路でも使っていたものです。

[**id研：マイクロマウスの壁センサ**](http://idken.net/posts/2020-02-09-mouse_irsensor/)

## 電源電圧

アナログ回路部分のopampの電源は+10Vと-3.3Vを使っています。
負側をGND=0Vではなくわざわざ-3.3Vにしているのは、opampの+端子が0Vに近い値になっても精度よく測定を行うためです。
今回使用したopampは入力端子電圧が電源電圧の1.5V内側でないと性能保証されていないので、負側電源を0Vにしてしまうと1.5V以上の電圧しか入力できなくなってしまいます。
それを防ぐために負側の電圧を0Vより少しだけ低い-3.3Vにしていました。

今思うと、**単電源というかグラウンドセンス可能なopampを使ったほうがよかったです**。
これらのopampは負側電源と同じがそれより少し低い電圧まで入力できます。
例えば負側電圧が0Vの場合、0Vや-0.5Vくらいまで入力できます。
こういうopampを使っておけば電源の部品も配線も減らすことができたのでしょう。

## GND

回路図上でGNDREFというシンボルで書かれている信号は、GNDにつながるスター配線された信号です。
これらはopampやADCのための基準電圧であるADC_REF、VBIASの基準となっています。

スター配線されたGNDで、根は出力の端子台のマイナス端子です。
電子負荷を使う立場に立つと基準のGNDは出力の端子台のところなのでこうしています。
電位的にはGNDと同じだいたい0Vなのですが、こうすることでGNDREFは他の部品からGNDに流れ込む電流による電圧降下の影響を受けないように配線され、VBIAS、ADC_REFの電圧精度が高まります。

結果として、この記事の終わりの失敗したことに書いてある通り、ケーブルの電圧降下があるのであまり意味はありませんでした。


## VBIAS

電圧電流測定回路の出力電圧の基準は0Vではなく、VBIASという名前の0.145Vに設定しています。
マイコンのADCで0V付近が精度よく測れないのを防ぐために、このように少しだけ正の電圧にオフセットさせています。


# マイコンでの測定とフィードバック制御

## ADC

マイコンとしてSTM32F373RCTを使っています。
電圧電流測定回路の出力はマイコンのSDADC(Sigma-delta ADC)でAD変換します。
マイコンのADC関連の回路とマイコンの設定、信号の流れは以下のようになっています。

![](/images/eload_micon.svg){:data-action="zoom"}

このADCは差動入力できるので、ADC負入力を測定回路近くでVBIASにつないで差動でADCに信号を伝えています。
ADCのサンプルは1.2MHz (データレート10kHzの120倍オーバーサンプル)で行われます。
サンプリング周波数が高いので、RCの1次フィルタでもエイリアスを生じないように高周波成分を落とすことができます。

ちなみにSTM32F373のSDADCについては「AN4550 Getting started with STM32F373/378CC/RC/VC SDADC」にSigma delta変調に関する基礎的なことから書かれています。
SDADCが120倍オーバーサンプルしているだとか、3次のsincフィルタになっているという記述はこのアプリケーションノートに書いてありました。
見落としていなければ、STM32F373のデータシートやリファレンスマニュアルに書かれていなかったので要注意です。

STM32F373のデータシートを見ていると、SDADCの特性のところにゲインエラーが以下のように書かれていました。

| Parameter  | Min  | Typ  | Max  | Unit |
|------------|------|------|------|------|
| Gain Error | -2.4 | -2.7 | -3.1 | %    |

結構大きいのと負側に偏っていて、常に負(ゲインが小さい)のが気になります。
実際に使ってみた感じでは、ゲインは数%はずれているのかもしれませんがゲインエラーは比較的安定しているようで、
一度ゲインを補正してやればそこから数%ずれるようなことはないようです。

## 電流フィードバック

電子負荷回路ではopampを使って電流測定値とDACによる設定電圧を比較して、MOSFETに流れる電流を制御していました。
その外側のループでは、マイコンでの電流測定値と電流設定値を比較してDAC設定値を決定する電流制御も行っています。
この制御ループがあるおかげで、ユーザーインターフェースで設定した電流設定値ピッタリの電流がMOSFETに流れます。

制御ループの構造を絵にすると以下のようになっています。

![](/images/eload_feedback.svg){:data-action="zoom"}

電子負荷回路のopampによる内側のフィードバックにより、
電子負荷回路の入力(=マイコンのDAC出力)→電流測定値までの伝達は1.6kHzまで帯域の伸びた1次遅れ系になります。
図の中のin→outはこの伝達を表しています。

マイコンでは外側のフィードバックを行っています。
外側の電流フィードバックがうまく働き、電流測定回路とADCで正確に電流も測定できている状態では、
DACなどの出力回路の精度が悪くても電流測定値=電流設定値になるように制御されます。

DACの初期ゲインエラーやゲインドリフト、電流制御部分のopampのオフセットはすべて外乱としてもモデル化できます。
マイコンの制御により系の外乱応答のゲインが十分に低い低周波領域では、これらの外乱は出力にほぼ表れなくなります。

制御しているといっても制御が効く周波数には限りがあります。
具体的には、電子負荷回路での電流フィードバックの帯域は1.6kHz、マイコンによる電流フィードバックの帯域は50Hzになっています。

マイコンには制御周期1msでPIコントローラを実装しています。
このコントローラのゲイン=1になる周波数は50Hz、ループの内側にある電子負荷回路の帯域は1.6kHzなので、
全体の一巡伝達も50Hzでゼロクロスする応答になります。
なので全体の電流設定値->出力電流の制御の帯域は50Hzになっています。

結果として、マイコンでの電流設定値→出力電流は50Hzにコーナーを持つLPFの特性、
DACや電子負荷回路のopampのドリフトなどの外乱→出力電流は50Hzにコーナーを持つHPFの特性になります。
電子負荷回路のところでも制御をしているので、出力電圧変動やMOSFETでのドリフト→出力電流は1.6kHzにコーナーを持つHPFの特性になります。

出力周りでの早い制御はopampが担い、UIでの設定値を達成するための遅い制御をマイコンが担当している構成です。

電子負荷としては帯域が低いですが、DCで大体引ければ十分だろうという設計になっています。
電流設定値はDCでしか設定しませんが、パルスを出したりランプ状に電流を変化させようとすると追従性のためにもっと制御の帯域は高めないといけないでしょう。


## 測定値の補正

電流電圧の測定値をなるべく高精度に得るために、ADCで測った値をそのまま測定値として扱うのでなく、
マイコン内部でオフセットとゲインを補正しています。

電流電圧のオフセット補正値は出力をONにする直前に測定した値を用いています。
出力リレーOFF時は電子負荷回路のFETのドレインをOpenではなくGNDに落としています。
これにより電圧測定値が0になるはずの状態を作れるので、このときの測定値を電圧オフセット値としています。
この状態では電流も流れないはずなので、同様にこのときの電流測定値を電流オフセット値としています。

出力リレーをONする直前に毎回このオフセット測定を行っているので、温度などによってopampやADCのオフセットがドリフトしてもうまく補正することができます。

一方でゲインは固定値の補正値をマイコンのFlashに書き込んで、毎回同じ値で補正することしかしていません。
信頼できるDMMを使って実際に流れた電流を測定し、マイコンでの測定値と比較をして補正ゲインを決定します。

測定ゲインには抵抗値のドリフトとADCの基準電圧のドリフトが効いてきますので、これらの部品はドリフトが十分に小さいものを選んでいます。
とはいえ測定値は液晶に3~4桁しか表示しないので、極端に高い部品を使わなくても実使用上は問題ありません。

# 放熱とファン制御

電子負荷回路のMOSFET周りは以下のような構造になっています。

![](/images/eload_heatsink.svg){:data-action="zoom"}


ポイントは以下の2点です。

* MOSFETの放熱面をPC用のCPUクーラーにくっつけて放熱している
* MOSFETのもう片面をべたパターンを介して温度センサーに接続し、MOSFETの温度を測定している

表面実装のMOSFETを基板に実装して基板にヒートシンクをつけようか、MOSFETを基板から分離して別の場所にあるヒートシンクにつけようか、いろいろ悩みました。
ケースを作るのが手間で基板だけで完結させたかったので今回のような構造になりました。
CPUクーラーを使うことで安く簡単に強力な放熱能力を得ることができました。

この電子負荷が電力をどこまで消費できるかはMOSFETの温度によって制限されます。
どこまでいけるかを知るために、また危険な状態になったときに停止するために温度センサーを取り付けました。
MOSFETのダイ温度になるべく近い温度を測定できるように、MOSFETのパッケージ面をべたパターンを使って熱的に温度センサーに接続しました。

現状では50Wを消費されたときに温度センサーの値は80℃を示します。
実際にダイ温度が何度なのかは簡単に知りようがありませんが、このくらいなら大丈夫そうなので

マイコンから温度センサーの値を読み取って液晶に表示しつつ、100℃を超えたら出力を遮断する機能を入れています。
また、ファンの回転数も常に最大にするとうるさいので、温度センサーの値に応じてファンの回転数を変化させています。


## ファンの制御

この電子負荷では、マイコンでTachoの信号からファンの実際の回転数を算出し、それが目標回転数になるようにファンのPWMを決定するフィードバック制御を行っています。
PIコントローラで目標回転数→実際の回転数の時定数が1.6秒くらいになる、ゆっくりとした制御を行っています。
ファンの目標回転数はMOSFET近くの温度センサーの値を使って、事前に決めた「A~B℃のときは目標回転数をC rpmにする」というルールで決定しています。

## CPUクーラーのコネクタ

PCのCPUクーラーでよく使われている4pinのコネクタは以下のもののようです。
Digikeyなどで買えるものでした。

![](/images/eload_molex.jpg){:data-action="zoom"}

|            | Manufacturer | Parts Number |
|------------|-------------|--------------|
| 基板側     | Molex       | 470531000    |
| ケーブル側 | Molex       | 470541000    |
| コンタクト | Molex       | 08500113     |

CPUクーラーのファンに生えている4pinは以下のような機能を持っています。

|  pin番号   | 名前 | 機能 | 使い方 |
|------------|-------------|--------------|-----|
| 1 | GND       | -    | GNDにつなぐ |
| 2 | +12V       | -    | +12V電源につなぐ |
| 3 | Tacho       | ファン0.5回転につきduty50%の矩形波が1周期出力される    | Open drain出力 |
| 4 | PWM       | ファンの回転数をPWMで入力する     | Open drainで入力する |

TachoとPWMはどちらもopen drain出力入力なので、マイコンなどの制御回路の電源電圧が12Vでなくても使いやすいようになっています。

Tachoからはパルスがでてくるので、
マイコンのTimerのinput captureを使ってパルス幅を測定することでファンの回転数に取得しています。

# 失敗したこと

## 電圧が測れない

電圧測定回路を積んでいるので一応電圧が測れます。
ところがコネクタはHi-GNDの2端子しかないのでケーブルでの電圧降下の影響を受けてしまい、測定対象の出力端での電圧とは違った電圧しか測れません。
抵抗値が高い細いケーブルに大きな電流を流したときに、この誤差は特に大きくなります。

基板上でGNDの引き回しを気にしてGNDREFとかを用意していたのがまるで意味のないものになってしましました。
確かに基板の内側では4端子測定のようなことができていましたが、基板の外側のケーブルのことを忘れていました。
測定対象の回路の出力端での電圧を測るために、電圧測定用の端子も用意して電源装置によくあるリモートセンスのようにすべきでした。


## 液晶の制御が大変

なんとなく安かったカラー液晶を使いましたが、これが大きな間違いでした。
マイコンに画面一枚分のデータが入らないので、液晶の画面の描画部分を作るのが非常に面倒でした。
ソフトを作るのにかかった時間の半分以上は液晶関連に割かれてしまいました。

また、数値の更新のたびに画面がチラチラしてしまいます。
画面描画のたびに数字の部分だけ、一旦背景色で消してから新たな文字で上書をしています。
画面上で実際に上記のような書き換えが行われるので、背景色が一瞬表示されてしまい、それがちらつきの原因になっているようです。

1画面分のメモリが用意できないにしても、狭い表示領域に限定して上記のような書き換えを行い、最終版をLCDに転送すれば解決できたのだと思います。
ただ、もう面倒なのでやめてしまいました。

結局数字と文字を表示しているだけなので、キャラクタディスプレイを使うべきでした。
もしくは、カラー液晶を使う場合は液晶1画面分のデータを展開できる大きさのメモリを用意すべきでした。
実際に液晶の描画部分を作ってみて、メモリに1画面のデータが入るか入らないかが手間や実装方法の分水嶺になっているという学びが得られました。

## 基板が割れそう

CPUクーラーを基板に直付けして荷重を基板で支えてしまっているせいか、目で見てわかるくらいに基板がたわんでいます。
そういえばCPUクーラーをマザーボードに取り付けるときは基板の表と裏に何か板金部品があったので、そういう頑丈な部品で荷重をさせないといけないのかもしれないです。

# 終わりに

作ってみたら意外と便利だったので、より使いやすくするためにちゃんとしたものを作ろうと思います。
放熱、使い勝手のためにケースをつけ、電源もAC入力できるようにしたいです。
