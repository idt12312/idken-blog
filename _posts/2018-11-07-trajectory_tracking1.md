---
layout: post
title: 独立二輪車型ロボットで目標軌道に追従する制御をする①
category: マイクロマウス
tag:
    - マイクロマウス
    - 制御
comments: true
thumb: /images/thumb_trajectory_track_trajectory.svg
---
最近マイクロマウス界隈で話題になっている目標軌道に追従する制御について、
自分のやっていることを書きます。Part1


# 目次
これは2部構成のうちの1つ目の記事です。

1. [**独立二輪車型ロボットで目標軌道に追従する制御をする①**](/posts/2018-11-07-trajectory_tracking1)
2. [独立二輪車型ロボットで目標軌道に追従する制御をする②](/posts/2018-11-07-trajectory_tracking2)


# はじめに
この記事では目標軌道に追従する制御について、マイクロマウス機体において自分がやっていることを書いています。


制御方法自体はこの後紹介する独立二輪車なら適応できるものになっているので、その範囲で一般化して書いています。
ただし例についてはマイクロマウスを題材にしていきます。

このページでは軌道追従制御について調べたこと、思ったことを書いています。
[その2のページ](/posts/2018-11-07-trajectory_tracking2)で実際に自分がマイクロマウスに実装した方法を紹介しています。

## 扱う制御対象
今回はいわゆる独立二輪車の制御について考えます。
まずは制御対象を定義します。

![](/images/trajectory_model.svg){:data-action="zoom"}

ロボットの状態は絶対座標系での位置と姿勢とし、時刻$$t$$での状態を$$(x(t), y(t), \theta(t))$$と表します。
$$u_v(t)$$と$$u_{\omega}(t)$$は時刻$$t$$でのロボットの速度入力(速度目標値)で、それぞれ並進速度目標値と回転速度目標値を表しています。
今回は議論を簡単にするために、
**速度目標値$$u_v(t), u_{\omega}(t)$$をロボットに入力すると、即座にロボットの並進速度が$$u_v(t)$$、回転速度が$$u_{\omega}(t)$$になる**と仮定します。
実際には目標速度を速度コントローラに設定してからその速度になるまでは遅れがあります。

ロボットの状態$$(x(t), y(t), \theta(t))$$と速度入力$$u_v(t), u_{\omega}(t)$$の間には以下の関係が成り立つとします。

$$
\begin{align}
    \left\{
    \begin{array}{l}
        \dot{x} &=& u_v \cos{\theta} \\
        \dot{y} &=& u_v \sin{\theta} \\
        \dot{\theta} &=& u_{\omega}
    \end{array}
    \right.
\end{align}
$$

以降ではこの制御対象に対する制御問題を考えていきます。

## 軌道に追従する制御とは
軌道というのはパラメータ(実質時刻)$$t$$をつかって$$(x_r(t), y_r(t))$$と表せられる、二次元平面上の点の集合のことです。
重要なのはこの目標軌道$$(x_r(t), y_r(t))$$は**どこを走るか**ではなく**いつどこを走るか**という情報を持っていることです。
軌道という言葉のニュアンスについてはTokoroさんのブログに書いてあります。

**[Tokoro's Tech-Note：軌道と経路の違い](https://blog.tokor.org/2015/12/01/%E8%BB%8C%E9%81%93%E3%81%A8%E7%B5%8C%E8%B7%AF%E3%81%AE%E9%81%95%E3%81%84/)**

今回考える軌道追従制御とは、
**ある目標軌道$$(x_r(t), y_r(t))$$が与えらたとき、
ロボットの状態$$(x(t), y(t), \theta(t))$$を使って入力$$u_v(t), u_{\omega}(t)$$を決定することで、
ロボットの位置$$(x(t), y(t))$$を目標軌道に収束させること**です。

![](/images/trajectory_track_trajectory.svg){:data-action="zoom"}

軌道追従コントローラは、ロボットの位置をフィードバックして軌道追従を達成しようとしています。
マイクロマウスでは軌道追従をしているかしていないかというよりも、
位置のフィードバックをしているかしていないかと考えてもいいかも知れません。

ここではロボットの状態は分かるものとしています。
ロボットの状態の真の値を得ることはできませんが、
マイクロマウスにおいては
ジャイロセンサやタイヤにつけたロータリーエンコーダを使ってロボット自身の位置と姿勢を推定することができます。
私はSTのTofセンサも使って位置の推定をしています。

目標軌道はなんでもいいわけではなく、今回は独立二輪車が連続な速度入力によって走行可能(実現可能)なものに限ります。
この制約を満たす目標軌道は、簡単には独立二輪車の轍(わだち)であるものです。

目標軌道には$$\theta_r(t)$$みたいな角度の情報がなく、ロボットの角度$$\theta(t)$$も制御していないのが今回のポイントです。
角度を制御しない理由は2つあります。
1つ目は軌道追従をする上では制御しなくてもいいからです。
今回の目標軌道は独立二輪車が実現可能な軌道としているので、$$x_r(t), y_r(t)$$を決定すると自ずと式の拘束から$$\theta_r(t)$$も決まってしまいます。
2つ目は難しいからです。
角度まで制御すると劣駆動システムの制御問題になってしまい、制御が難しくなります。
これについてもTokoroさんのブログに書いてあります。

**[Tokoro's Tech-Note：マイクロマウスと制御理論 (2)自由度と非ホロノミック拘束](https://blog.tokor.org/2016/01/04/%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%83%9E%E3%82%A6%E3%82%B9%E3%81%A8%E5%88%B6%E5%BE%A1%E7%90%86%E8%AB%96-2-%E8%87%AA%E7%94%B1%E5%BA%A6%E3%81%A8%E9%9D%9E%E3%83%9B%E3%83%AD%E3%83%8E%E3%83%9F%E3%83%83%E3%82%AF%E6%8B%98%E6%9D%9F/)**

感覚としては、今はロボットへの入力は並進と回転の2次元なので簡単に制御できるのは2次元の位置までです。
入力の広がりが2次元しかないのに、角度まで入れて3次元のものを制御しようとすると難しいという感じです。

マイクロマウスの大会などで「軌道に追従する制御をしています」と言うと、
目標状態の列

$$(x_{r1}, y_{r1}, \theta_{r1}), (x_{r2}, y_{r2}, \theta_{r2}), \cdots$$

を各時間ごとに実現しているように思われることが多いのですが、そうではありません。

![](/images/trajectory_track_point.svg){:data-action="zoom"}

今考えている軌道追従制御では目標軌道上の点$$(x_r(t), y_r(t)$$は時間に対して連続的に移動をし、
ある時刻$$t$$においても点は速度や加速度を持っています。目標位置を点列で与えているのではありません。

この記事では理想的な連続時間の話を考えていますが、最終的には時間を離散化してマイコンなどに実装します。
実装時には目標軌道も離散化され、目標位置の点列っぽくなっているかもしれません。
ただ、その場合でも目標となる点には位置だけではなく速度の情報も含める必要があります。


## 位置をフィードバックするといいこと
位置をフィードバックしていると、例えばある直線上を走っているときに、進行方向と垂直な方向にズレてしまっても直線上に戻ってくることができます。
位置をフィードバックしていなければ、ある時点で直線からズレてしまってもズレたことを認識して直線上に戻ってくることはできません。

マイクロマウスでは位置をフィードバックしていなくても、
壁センサを使って左右の壁との距離が等しくなるように進行方向を調整すると、壁と壁の中心をまっすぐ走ることができます(壁制御、壁トレース制御)。
この方法は非常に厚い実績がある方法なのですが、例えば両側に壁がなかったりする場合は走る位置を修正することができません。
両側に壁がなかったとしても自己位置の推定 + 軌道追従制御(位置のフィードバック)をしていれば走って欲しい場所を走ってくれます。

カーブ中や斜め走行中は前述の壁制御ができないので、
位置をフィードバックしていなければ事前に計画された並進速度と回転速度をロボットにフィードフォワード的に与えて走るしかありません。
一方で位置をフィードバックしていれば位置のズレを認識して修正できるのです。

## 位置をフィードバックすることの微妙なところ
推定した自己位置をフィードバックするので、自己位置の推定精度が重要になります。
タイヤが滑ってロータリーエンコーダのセンサ値がズレたり、ジャイロセンサの誤差にうまく対処できないと自己位置の推定精度が悪くなり、
結果的に思った通りに走ってくれなくなります。フィードフォワード的に速度目標値を与える方法と比べて、ある意味でセンサの誤差に敏感になってしまっているとも考えられます。

またマイクロマウスでは、**位置をフィードバックしたからといって速く走れるというわけではない**という事実があります。
位置をフィードバックするのは、ちゃんと走るアプローチの一つだと思っています。


続き：[独立二輪車型ロボットで目標軌道に追従する制御をする②](/posts/2018-11-07-trajectory_tracking2)

