---
layout: post
title: 独立二輪車型ロボットで目標軌道に追従する制御をする
category: マイクロマウス
tag:
    - マイクロマウス
    - 制御
comments: true
thumb: /images/thumb_trajectory_track_trajectory.svg
---
最近マイクロマウス界隈で話題になっている目標軌道に追従する制御について、
自分のやっていることを書きます。


# はじめに
この記事では目標軌道に追従する制御について、マイクロマウス機体において自分がやっていることを書いています。
制御方法自体はこの後紹介する独立二輪車なら適応できるものになっているので、その範囲で一般化して書いています。
ただし例についてはマイクロマウスを題材にしていきます。

この記事の序盤では軌道追従制御について調べたこと、思ったことを書いています。
後半で実際に自分がマイクロマウスに実装した方法を紹介しています。

## 扱う制御対象
今回はいわゆる独立二輪車の制御について考えます。
まずは制御対象を定義します。

![](/images/trajectory_model.svg){:data-action="zoom"}

ロボットの状態は絶対座標系での位置と姿勢とし、時刻$$t$$での状態を$$(x(t), y(t), \theta(t))$$と表します。
$$u_v(t)$$と$$u_{\omega}(t)$$は時刻$$t$$でのロボットの速度入力(速度目標値)で、それぞれ並進速度目標値と回転速度目標値を表しています。
今回は議論を簡単にするために、
**速度目標値$$u_v(t), u_{\omega}(t)$$をロボットに入力すると、即座にロボットの並進速度が$$u_v(t)$$、回転速度が$$u_{\omega}(t)$$になる**と仮定します。
実際には目標速度を速度コントローラに設定してからその速度になるまでは遅れがあります。

ロボットの状態$$(x(t), y(t), \theta(t))$$と速度入力$$u_v(t), u_{\omega}(t)$$の間には以下の関係が成り立つとします。

$$
\begin{align}
    \left\{
    \begin{array}{l}
        \dot{x} &=& u_v \cos{\theta} \\
        \dot{y} &=& u_v \sin{\theta} \\
        \dot{\theta} &=& u_{\omega}
    \end{array}
    \right.
\end{align}
$$

以降ではこの制御対象に対する制御問題を考えていきます。

## 軌道に追従する制御とは
軌道というのはパラメータ(実質時刻)$$t$$をつかって$$(x_r(t), y_r(t))$$と表せられる、二次元平面上の点の集合のことです。
重要なのはこの目標軌道$$(x_r(t), y_r(t))$$は**どこを走るか**ではなく**いつどこを走るか**という情報を持っていることです。
軌道という言葉のニュアンスについてはTokoroさんのブログに書いてあります。

**[Tokoro's Tech-Note：軌道と経路の違い](https://blog.tokor.org/2015/12/01/%E8%BB%8C%E9%81%93%E3%81%A8%E7%B5%8C%E8%B7%AF%E3%81%AE%E9%81%95%E3%81%84/)**

今回考える軌道追従制御とは、
**ある目標軌道$$(x_r(t), y_r(t))$$は与えらたとき、
ロボットの状態$$(x(t), y(t), \theta(t))$$を使って入力$$u_v(t), u_{\omega}(t)$$を決定することで、
ロボットの位置$$(x(t), y(t))$$を目標軌道に収束させること**です。

![](/images/trajectory_track_trajectory.svg){:data-action="zoom"}

軌道追従コントローラは、ロボットの位置をフィードバックして軌道追従を達成しようとしています。
マイクロマウスでは軌道追従をしているかしていないかというよりも、
位置のフィードバックをしているかしていないかと考えてもいいかも知れません。

ここではロボットの状態は分かるものとしています。
ロボットの状態の真の値を得ることはできませんが、
マイクロマウスにおいては
ジャイロセンサやタイヤにつけたロータリーエンコーダを使ってロボット自身の位置と姿勢を推定することができます。
私はSTのTofセンサも使って位置の推定をしています。

目標軌道はなんでもいいわけではなく、今回は独立二輪車が連続な速度入力によって走行可能(実現可能)なものに限ります。
この制約を満たす目標軌道は、簡単には独立二輪車の轍(わだち)であるものです。

目標軌道には$$\theta_r(t)$$みたいな角度の情報がなく、ロボットの角度$$\theta(t)$$も制御していないのが今回のポイントです。
角度を制御しない理由は2つあります。
1つ目は軌道追従をする上では制御しなくてもいいからです。
今回の目標軌道は独立二輪車が実現可能な軌道としているので、$$x_r(t), y_r(t)$$を決定すると自ずと式の拘束から$$\theta_r(t)$$も決まってしまいます。
2つ目は難しいからです。
角度まで制御すると劣駆動システムの制御問題になってしまい、制御が難しくなります。
これについてもTokoroさんのブログに書いてあります。

**[Tokoro's Tech-Note：マイクロマウスと制御理論 (2)自由度と非ホロノミック拘束](https://blog.tokor.org/2016/01/04/%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%83%9E%E3%82%A6%E3%82%B9%E3%81%A8%E5%88%B6%E5%BE%A1%E7%90%86%E8%AB%96-2-%E8%87%AA%E7%94%B1%E5%BA%A6%E3%81%A8%E9%9D%9E%E3%83%9B%E3%83%AD%E3%83%8E%E3%83%9F%E3%83%83%E3%82%AF%E6%8B%98%E6%9D%9F/)**

感覚としては、今はロボットへの入力は並進と回転の2次元なので簡単に制御できるのは2次元の位置までです。
入力の広がりが2次元しかないのに、角度まで入れて3次元のものを制御しようとすると難しいという感じです。

マイクロマウスの大会などで「軌道に追従する制御をしています」と言うと、
目標状態の列

$$(x_{r1}, y_{r1}, \theta_{r1}), (x_{r2}, y_{r2}, \theta_{r2}), \cdots$$

を各時間ごとに実現しているように思われることが多いのですが、そうではありません。

![](/images/trajectory_track_point.svg){:data-action="zoom"}

今考えている軌道追従制御では目標軌道上の点$$(x_r(t), y_r(t)$$は時間に対して連続的に移動をし、
ある時刻$$t$$においても点は速度や加速度を持っています。目標位置を点列で与えているのではありません。

この記事では理想的な連続時間の話を考えていますが、最終的には時間を離散化してマイコンなどに実装していくので、
実装時には目標位置のの点列っぽくなっているかもしれません。
ただ、その場合でも目標となる点には位置だけではなく速度の情報も含める必要があります。


## 位置をフィードバックするといいこと
位置をフィードバックしていると、例えばある直線上を走っているときに、進行方向と垂直な方向にズレてしまっても直線上に戻ってくることができます。
位置をフィードバックしていなければ、ある時点で直線からズレてしまってもズレたことを認識して直線上に戻ってくることはできません。

マイクロマウスでは位置をフィードバックしていなくても、
壁センサーを使って左右の壁との距離が等しくなるように進行方向を調整すると、壁と壁の中心をまっすぐ走ることができます(壁制御、壁トレース制御)。
この方法は非常に厚い実績がある方法なのですが、例えば両側に壁がなかったりする場合は走る位置を修正することができません。
両側に壁がなかったとしても自己位置の推定 + 軌道追従制御(位置のフィードバック)をしていれば走って欲しい場所を走ってくれます。

カーブ中や斜め走行中は壁制御ができないので、
位置をフィードバックしていなければ事前に計画された並進速度と回転速度をロボットにフィードフォワード的に与えて走るしかありません。
一方で位置をフィードバックしていれば位置のズレを認識して修正できるのです。


## 参考資料
軌道追従制御、特に以降で紹介する制御に関して情報を得るのに役立った資料を紹介しておきます。

[**1. Control of Wheeled Mobile Robots: An Experimental Overview**](https://link.springer.com/chapter/10.1007/3-540-45000-9_8)<br>
これは[SpringerのRamsete:Articulated and Mobile Robotics for Services and Technologies](https://www.researchgate.net/publication/321620382_Ramsete_Articulated_and_Mobile_Robotics_for_Services_and_Technologies)
という本の一つの章です。運良くResearchGateで無償公開されていました。
以降出てくる、私自身がマイクロマウスの機体に実装している制御手法はこの文献に書いてあったものです。


[**2. 三平研究室：講義資料**](http://www.sl.sc.e.titech.ac.jp/SCHP/tool.html)<br>
微分幾何学に基づいた非線形制御理論についての基礎的な部分がまとめてある資料達です。
学校の授業でこういう分野があることを知り、まずはこのあたりの資料を中心に勉強しました。

[**3. A stable tracking control method for an autonomous mobile robot**](https://ieeexplore.ieee.org/document/126006)<br>
話はそれますが、今回紹介する方法とは違った制御手法のものです。
イメージもしやすく、安定性の証明も実装も非常に簡単なので最初はこの方法を使っていました。
ただ、漸近安定までしか証明できないせいか、マイクロマウスではカーブ直後にどうしてもふらつくような感じがったので使うのをやめてしまいました。
パラメータがだめなだけだったかも知れないです。


# 自分がやっている制御
いよいよ本題です。
色々試した結果、入出力の線形化フィードバックを用いて軌道追従制御を実現しています。
制御対象に補償器を取り付けることで線形化し、線形化された制御対象に対して軌道追従を達成するコントローラーを取り付けていきます。
軌道追従制御を知らない状態でこの記事を読むと、軌道追従制御はこれしかないように思えてしまうかも知れませんが、
ある1つの方法でしかないことは忘れないでください。

## 制御対象
冒頭でも出てきましたが、もう一度書いておきます。
今回は以下のような速度目標値$$u_v, u_{\omega}$$が入力、ロボットの位置$$x, y$$が出力、ロボットの姿勢$$\theta$$を内部状態にもつ制御対象$$P$$を考えます。

![](/images/trajectory_block_plant.svg){:data-action="zoom"}

制御対象$$P$$の入出力の関係は以下のように書けるとします。

$$
\begin{align}
    P : \left\{
    \begin{array}{l}
        \dot{x} &=& u_v \cos{\theta} \\
        \dot{y} &=& u_v \sin{\theta} \\
        \dot{\theta} &=& u_{\omega}
    \end{array}
    \right.
\end{align}
$$


## Step1：線形化フィードバックを作る
参考文献1で紹介されていた方法です。
下準備ですがこれが肝です。
なんでそんなのを思いついたの??となった人は参考文献を読んでください。
ここで語るのは非常に大変なので省略します。

新しい入力$$u_x, u_y$$を導入して、
$$u_x, u_y \to x,y$$が線形システムとなるような補償器$$C$$を$$P$$に取り付けます。

![](/images/trajectory_block_linearize.svg){:data-action="zoom"}

補償器$$C$$は入力が$$u_x, u_y$$、出力が$$u_v, u_{\omega}$$で、$$P$$の内部状態$$\theta$$を取得できるとします。
この補償機は内部状態$$\xi \neq 0$$($$\neq 0$$については後述)をもち、入出力と内部状態の関係は以下のようにします。

$$
\begin{align}
    C : \left\{
    \begin{array}{l}
        \dot{\xi} &=& u_x \cos{\theta} +  u_y \sin{\theta} \\
        u_v &=& \xi \\
        u_{\omega} &=& \frac{u_y \cos{\theta} - u_x \sin{\theta}}{\xi}
    \end{array}
    \right.
\end{align}
$$

制御対象$$P$$と補償器$$C$$を接続した閉ループ系を$$P_l$$とします。
驚くべきことに、補償器をとりつけることで$$P_l$$のダイナミクスは以下のようになります。

$$
\begin{align}
    P_l : \left\{
    \begin{array}{l}
        \ddot{x} &=& u_x \\
        \ddot{y} &=& u_y 
    \end{array}
    \right.
\end{align}
$$

図にするとこんな感じです。

![](/images/trajectory_block_linearize_eq.svg){:data-action="zoom"}

なんと超簡単な線形システムになってしまいました。
これの証明は$$\ddot{x}, \ddot{y}$$を計算するだけです。

$$
\begin{align}
    \begin{array}{l}
        \ddot{x} &=& -\dot{\theta} \sin{\theta} u_v + \cos{\theta} \dot{u_v} \\
                 &=& -u_{\omega} \sin{\theta} \xi + \cos{\theta} \dot{\xi} \\
                 &=& -(u_y \cos{\theta} - u_x \sin{\theta}) \sin{\theta} + \cos{\theta} (u_x \cos{\theta} + u_y \sin{\theta}) \\
                 &=& -u_y \cos{\theta} \sin{\theta} + u_x \sin^2{\theta} + u_x \cos^2{\theta} + u_y \cos{\theta} \sin{\theta} \\
                 &=& u_x
    \end{array}
\end{align}
$$

$$\ddot{y}$$も同じように計算できます。

ここまでで補償器$$C$$を使うことで$$u_x, u_y$$から$$x,y$$へのダイナミクスを線形化することができました。
しかもただ線形化されただけではなく、$$x$$のダイナミクスと$$y$$のダイナミクスも入力も完全に分離されています。

ここまで来てしまえば、後は線形システムの制御の色々が適応できるので割となんでもできます。
以降では軌道追従コントローラを作っていきます。

## Step2：軌道追従コントローラを作る
目標軌道は$$(x_r(t), y_r(t))$$でした。
ここでは先程出てきた$$\xi \neq 0$$を達成するために、いかなる時刻$$t$$においても
$$\dot{x}^2_r(t) + \dot{y}^2_r(t) \neq 0$$、つまり**並進速度が0にならない**とします。

機体の位置である$$x(t), y(t)$$をこの目標軌道に追従(収束)させるために、
以下のようなコントローラ$$K$$を取り付けます。

![](/images/trajectory_block_controller.svg){:data-action="zoom"}

コントローラ$$K$$は目標軌道$$x_r, y_r$$を入力とし、補償機への入力$$u_x, u_y$$を出力とする線形システムで、
その入出力は以下のようにします。

$$
\begin{align}
    K : \left\{
    \begin{array}{l}
        u_x &=& \ddot{x}_r + K_{x1} (\dot{x}_r - \dot{x}) + K_{y2} (x_r - x) \\
        u_y &=& \ddot{y}_r + K_{y1} (\dot{y}_r - \dot{y}) + K_{y2} (y_r - y)
    \end{array}
    \right.
\end{align}
$$

コントローラ$$K$$を取り付けたとき、$$\lim_{t \to \infty}(x_r(t) - x(t)) = 0$$となる必要十分条件は$$K$$のパラメータ$$K_{x1}, K_{x2}$$が$$K_{x1}>0, K_{x2}>0$$を満たすことです。
また、$$y$$に関しても$$\lim_{t \to \infty}(y_r(t) - y(t)) = 0$$となる必要十分条件は$$K$$のパラメータ$$K_{y1}, K_{y2}$$が$$K_{y1}>0, K_{y2}>0$$を満たすことです。

コントローラ$$K$$と線形化されたシステム$$P_l$$の閉ループ系のダイナミクス$$P_{cl}$$は次のようになります。

$$
\begin{align}
    P_{cl} : \left\{
    \begin{array}{l}
        \ddot{x} &=& \ddot{x}_r + K_{x1} (\dot{x}_r - \dot{x}) + K_{y2} (x_r - x) \\
        \ddot{y} &=& \ddot{y}_r + K_{y1} (\dot{y}_r - \dot{y}) + K_{y2} (y_r - y)
    \end{array}
    \right.
\end{align}
$$

軌道追従誤差$$e_x(t) := x_r(t) - x_r(t), \ e_y(t) := y_r(t) - y_r(t)$$を定義すると、
この追従誤差は以下のダイナミクスに従います。

$$
\begin{align}
    \left\{
    \begin{array}{l}
        \ddot{e}_x + K_{x1} \dot{e}_x + K_{x2} e_x = 0 \\
        \ddot{e}_y + K_{y1} \dot{e}_y + K_{y2} e_y = 0
    \end{array}
    \right.
\end{align}
$$

これは2次の線形微分方程式なので、
$$\lim_{t \to \infty} e_x(t) = 0$$となる必要十分条件は$$K_{x1} > 0$$かつ$$K_{x2} > 0$$で、
$$\lim_{t \to \infty} e_y(t) = 0$$となる必要十分条件は$$K_{y1} > 0$$かつ$$K_{y2} > 0$$です。

とりあえず制御パラメータ$$K_{x1}, K_{x2}, K_{y1}, K_{y2}$$は正に選んでおけば軌道追従を達成できるというわけです。
しかも追従誤差が式(8)のダイナミクスに従うわけですから、追従誤差が指数関数的に減少するような制御(指数安定)が可能です。

安定性以外の制御性能に関しても線形の2次系と同様に考えることができます。
2次系を考えることで制御パラメータをとにかく収束が速くなるものに選んだり、
オーバーシュートがでないように選んだりすることができます。

ここまでで紹介した方法のポイントは、補償器をとりつけることで制御系の入出力を線形化していることです。
一般的に非線形制御で安定性に加えて制御性能まで議論をすることを難しいのですが、
制御対象を一旦線形化することで線形制御の道具達を活用できることが最大の特徴です。


## 問題点
### $$\xi = 0$$が特異点になっている
補償器$$C$$の内部状態$$\xi$$は0になってはいけません。
自ずと$$\xi = 0$$になるのではなく、$$\xi = 0$$となるようにケアしてやらないといけないのです。
私はそれを達成するために、速度が閾値以上の領域ではここまでで紹介した方法で制御を行い、
閾値以下の領域では目標速度をフィードフォワード的に与えるだけにしています。

### 内部状態$$\theta, \xi$$の安定性(有界性)は？
自分は証明できていません。
参考文献1にはこの手法の詳細はSpringerの本に書いてるとあるのですが、
Springerの本が入手できていないので(高い!!)先見の明も得られない状態です。

# 実装してみた
今作っているマイクロマウスのハーフサイズ競技用のマシンには、ここまでで紹介した軌道追従制御を実装しています。
ちゃんと走っているので、この記事で紹介した方法は机上の空論ではないということです。

<blockquote class="twitter-tweet" data-lang="ja"><p lang="ja" dir="ltr">マウス氏、速くなった <a href="https://t.co/Bvo8UNxJYn">pic.twitter.com/Bvo8UNxJYn</a></p>&mdash; id (@idt12312) <a href="https://twitter.com/idt12312/status/1055454766178828289?ref_src=twsrc%5Etfw">2018年10月25日</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

